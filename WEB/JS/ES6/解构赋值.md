# 解构赋值

> 从数组和对象中取值，对变量赋值
>
> 原理：模式匹配（结构相同）。数据类型不重要，重要的是结构是否相同、被解构数据是否具有 Iterator 接口

## 数组解构

按照顺序赋值

### 完全解构

> 模式完全匹配

```javascript
// 数组解构赋值
let [a, b, c] = [1, 2, 3];
// 对象解构赋值
let { foo, bar } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"
// 字符串解构赋值
let [a,b,c] = 'abc'
a // 'a'
b // 'b'
c // 'c'
```

### 不完全解构

> 模式部分匹配

```javascript
let [a,b] = [1,2,3];
a // 1
b // 2

let [a,[b],c] = [1,[2,3],4];
a // 1
b // 2
c // 4
```

### 解构失败

> 值是 undefined 或报错

```javascript
let [a,b,c] = ['1']
a // "1"
b // undefined
c // undefined

let [a,b] = {}	// 报错
```

### 默认值

解构赋值允许指定默认值，当解构得到的值严格等于 undefined 时，默认值生效

```javascript
let [a,b = 2] = [1];
a // 1
b // 2

let [a,b = 2] = [1,undefined];
a // 1
b // 2

let [a = 1] = [null];	// 得到的值不严格等于 undefined，默认值不生效
a // null
```

如果默认值是表达式，则表达式是惰性求值（只有在用到默认值的时候，才会求值）

```javascript
let [a = f()] = [null];		// 默认值不生效，没有调用函数
a // null
```

默认值可以使用解构赋值中，已经声明的变量

```javascript
let [a = 1,b = a] = [];
a // 1
b // 1

let [a = b,b = 1] = [];	// Reference Error
```

## 对象解构

按照属性名赋值，找到同名属性，然后赋值给对应变量

```javascript
let {a,b} = {a:1,b:2};	// 等同于 let{a:a,b:b} = {a:1,b:2};
a // 1
b // 2
```

变量名与属性名不相同

> ‘:’左边是要匹配的属性名称，右边是真正存值的变量

```javascript
let {a:b} = {a:1};	// a 是匹配的属性名，b 是存值的真正变量
b // 1
```

### 解构失败

解构失败，值是 undefined

```javascript
let {a} = {b:1};
a // undefined
```

如果嵌套解构，父属性不存在，将会报错

```javascript
// 报错
let {foo: {bar}} = {baz: 'baz'};
```

如果要将一个已经声明的变量用于解构赋值，必须使用圆括号，否则报错

```javascript
let x;
{x} = {x:1};	// Syntax Error，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。
({x} = {x:1})；
```

### 嵌套解构

```javascript
let obj = {
    a:['abc',{
        b:1
    }]
}
let {a:[x,{y}]} = obj;
x // 'abc'
y // 1
```

### 默认值

> 对象解构也可以提供默认值，默认值在得到严格等于 undefined 的值时生效

```javascript
var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x: y = 3} = {};
y // 3

var {x: y = 3} = {x: 5};
y // 5
```

### 用法

将对象的某个方法，快速赋值到变量

```
let {log,sin,cos} = Math;
```

对数组进行对象解构

```javascript
let array = [1,2,3];
let {0:a,[array.length-1]:b} = array;
a // 1
b // 3
```

## 字符串解构

将字符串解构成字符数组

```javascript
let [a,b,c] = 'abc';
a // 'a'
b // 'b'
c // 'c'

let {length:len} = 'abc';
len // 3
```

## 数值和布尔值解构

> 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象（基础类型转换成包装类）。由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。

```javascript
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true

let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
```

## 函数参数解构

```javascript
function add([x,y]){
    return x+y;
}
add([1,2])
```

## 圆括号问题

> 对于编译器来说，一个式子是模式还是表达式，必须解析到（或解析不到）等号才能知道，所以碰到圆括号时，如何处理就成为了问题。

ES6 规定以下情况，不得使用圆括号：

1. 变量声明语句

```javascript
// 全部报错
let [(a)] = [1];

let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};

let { o: ({ p: p }) } = { o: { p: 2 } };
```

1. 函数参数（也属于变量声明）

```javascript
/ 报错
function f([(z)]) { return z; }
// 报错
function f([z,(x)]) { return x; }
```

1. 赋值语句

```javascript
// 全部报错
({ p: a }) = { p: 42 };
([a]) = [5];
```

## 解构用途

### 交换变量

```javascript
let a = 1,b = 2;
[a,b] = [b,a]
```

### 从函数返回多个值

```javascript
// 返回数组
function example(){
    return [1,2,3]
}
let [a,b,c] = example();

// 返回对象
function example(){
    return {
        a:1,
        b:2
    }
}
let {a,b} = exammple();
```

### 函数参数

```javascript
// 数组
function add([a,b]){
    return a+b
}
add([1,2]);

// 对象
function example({a,b}){
    ...
}
example({a:1,b:2});
```

### 提取 JSON 数据

```javascript
let jsonData = {
    id: 42,
    status: 'ok',
    data: [123,1234]
};
let {id,status,data} = jsonData;
id // 42
status // 'ok'
data // [123,1234]
```

