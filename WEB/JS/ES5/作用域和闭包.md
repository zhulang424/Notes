# 作用域

执行环境是什么？

> 执行环境是作用域的另一种说法

作用域是什么？

> 作用域决定了生命周期和可以访问的数据

作用域的种类？

> 全局作用域、局部作用域（函数）
>
> **不存在块级作用域！**

变量对象是什么？

> 作用域的内部实现，在代码执行过程中，解析器将每个作用域中定义的变量和函数都保存变量对象中

函数与作用域的关系？

> 每个函数都创建了一个局部作用域

全局作用域是什么？

> 全局执行环境是最外层的作用域，在浏览器中，全局作用域是 ```window```对象，所以全局变量和全局函数都是```window```对象的属性

作用域何时销毁？

> 作用域所有代码执行完毕后，作用域被销毁，其中定义的变量和函数也销毁
>
> 全局作用域直到应用程序退出才会被销毁

作用域链是什么？

> 代码执行时，会创建由当前作用域作为最底层，全局作用域作为最顶层，中间各级作用域组成的作用域链，定义了当前代码可以访问的所有数据
>
> 函数内部有一个```scope```属性，保存着作用域链
>
> 作用域链实际上由作用域的变量对象构成，作用域链保有对链上所有作用域的变量对象的引用

作用域链有什么用？

> 作用域链保证了标识符的解析（变量查询）
>
> 标识符的解析（变量查询）过程，从当前作用域开始,就是沿着作用域链，逐级向上搜索标识符的过程
>
> **所以，内部作用域可以访问外部作用域的数据，但是外部作用域不能访问内部作用域的数据**
>
> **所以，同名的局部变量会顶替全局变量**

```try-catch```、```with(){}```对作用域有什么影响？

> 因为不存在块级作用域，所以没有影响
>
> 在这两个语句中定义的变量都可以在其最近的局部作用域中访问

标识符解析（变量查询）的性能？

> 访问局部变量比在作用域链中查找变量更快
>
> 不过 JavaScript 引擎对变量查询优化的很好，性能差别不大

如何模仿块级作用域？

> 使用立即执行匿名函数
>
> ```javascript
> (function(){
>     // 块级作用域
> })()
> // 将函数声明包在圆括号中，表示函数表达式
> // 函数声明不可以直接接圆括号调用，但是函数表达式可以
> 
> // 立即执行匿名函数中创建的所有变量，在函数执行结束后被销毁
> ```

什么是私有变量？

> 在函数内部定义的变量是私有变量，因为无法从外部访问
>
> - 函数参数
> - 局部变量
> - 内部函数

# 闭包

什么是闭包？

> 可以访问另一个函数中数据的函数（内部函数）

闭包的原理？

> - 外部函数创建的作用域在内部函数的作用域链上，所以内部函数可以访问外部函数的数据
> - 内部函数作用域不被销毁（有变量保存着对内部函数的引用），则外部函数作用域也无法被销毁

闭包的使用场景？

> - 私有属性
> - 单例模式
> - 函数绑定
> - 函数柯里化

如何判断闭包访问的属性是否相同？

> 看闭包是不是同一个
>
> - 如果是同一个闭包，访问数据是相同（都是这个创建这个闭包的作用域中的数据）
> - 如果不是同一个闭包，访问数据不同的（每个闭包访问各自创建它们的作用域中的数据）

闭包的缺点？

> 因为外部函数的作用域无法被销毁，所以闭包会导致占用更多内存

闭包的注意事项？

> - 闭包只能访问外部函数中，所有数据的最后一个值，因为闭包保存的是整个作用域，而不是某个对象
> - 闭包访问的作用域是创建闭包时，外部函数创建的那个作用域

使用闭包实现‘类属性’

> 在构造函数中定义私有变量（类属性），然后在原型对象上定义特权方法，那么访问的数据是共享的（都是第一次执行构造函数时，构造函数创建的作用域内的私有变量）
>
> ```javascript
> function Person(name) {
>       if (typeof Person.prototype.getName !== 'function') {
>         Person.prototype.getName = function () {
>           return name
>         }
>         Person.prototype.setName = function (newName) {
>           name = newName
>         }
>       }
>     }
> 
>     var person1 = new Person('name1')
>     var person2 = new Person('name2')
>     alert('person1 name:' + person1.getName())	// name1
>     alert('person2 name:' + person2.getName())	// name1
> ```
>

使用闭包实现‘实例私有属性’

> 在构造函数中定义私有变量，在实例属性上定义特权方法，那么特权方法访问的数据各自独立（是每一次执行构造函数时，构造函数创建的作用域内的私有变量）
>
> ```javascript
> // 私有变量
> function Person(name) {
>       this.getName = function(){
>         return name
>       }
>       this.setName = function(newName){
>         name = newName
>       }
>     }
> 
>     var person1 = new Person('name1')
>     var person2 = new Person('name2')
>     alert('person1 name:' + person1.getName())	// name1
>     alert('person2 name:' + person2.getName())	// name2
> ```
>

用闭包实现单例模式

> 原理：创建立即执行匿名函数，在函数中定义私有变量，返回一个带特权方法（闭包）的对象

> 模块模式：使用单例（Object 类型实例）管理私有变量
>
> ```javascript
>  var singleton = (function(){
>     var name = 'tom'
>     return {
>         getName = function(){
>             return name
>         },
>         setName = function(newName){
>             name = newName
>         }
>     }
> })()
> ```
>

> 增强模块模式：使用某种特定类型单例管理私有变量
>
> ```javascript
> var singleton = (function(){
>     var name = 'tom'
>     var manager = new Manager()
>     manager.getName = function(){
>         return name
>     }
>     manager.setName = function(newName){
>         name = newName
>     }
>     retrun manager
> })()
> ```
>

