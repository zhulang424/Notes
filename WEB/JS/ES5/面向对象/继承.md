# 原型链

为什么会构成原型链？

- 每个对象都有实自己的原型对象
- 原型对象也是对象，也有自己的原型对象

实例-》原型对象-》原型对象的原型对象-》原型对象的原型对象的原型对象-》。。。-》Object.prototype的原型对象（null）

原型链的尽头就是Object.prototype的原型，是null

所有对象都继承了Object.prototype的属性，所以所有对象都有valueOf、toString

访问对象属性的过程：去对象中找，找不到就去原型对象上找，原型对象上也没有就去原型对象的原型对象上找，一直上溯到Object.prototype，如果还找不到，返回undefined

沿着原型链查找属性是耗费性能的，上溯到越上层，耗费性能越大。如果访问一个不存在的属性，需要遍历整个原型链

如果实例属性和原型属性同名，实例属性会覆盖原型属性



instanceof

左边实例，右边构造函数

检查构造函数的原型对象，在不在实例的原型链上

等同于 构造函数.prototype.isPrototypeOf(实例)